# 现代编程语言是否仍旧需要自增自减运算符

-----

## 结论

不需要！

例如 Python Ruby 等已经弃用了自增自减运算符。

具体分析如下：

## 起源

自增自减运算符最早出现在 B语言 。

B语言的作者之一 Ken Thompson 并未表述过自己创建它的原因。
但是有一个流传甚广的说法， 当然这只是一个误解。

据传， 这两个运算符是为了对应汇编指令 `INC` 和 `DEC` 。
（PDP-11指令集）

然而， B语言 诞生早于 PDP-11 并且 B语言并不直接编译为机器码。

## 更高的效率？

经过查阅资料， 绝大部分编译器无论是否进行优化， 都不会把 `i++` 编译成 `INC` ,
以此来提高运行速度， 以 gcc 为例， 对于编译器而言， `i++` 与 `i += 1` 没有区别。
当然对于其他编译器也一样。

## 原子性？

要明确的是， `i++` 这种及其简短的语句或表达式， 并不是一个原子操作，
`i += 1` 也不是原子操作， 甚至 `INC` 这样的单指令也不是原子的。

## 简洁性

自增自减运算符在 C/C++ 中被广泛的使用，尤其在for循环等地方。

举两个例子：

``` C
for (int i = 0; i != n; ++i) {
  // do something
}
```

``` C
while (*dst++ = *from++) ;
```

C语言这类早期语言不具有迭代器、 范围等能力， 并且及其依赖指针操作，
同时依靠自增自减运算符和其他特性可以把代码合并至一行，
使得代码极为简洁。

## 副作用

在许多编程语言中， 部分表达式具有副作用。

在运算符中， 具有副作用的除了赋值运算符
（包括但不限于 `=`, `+=`, `&=`, `<<=`等），
就只有自增自减运算符。

甚至部分语言不认为赋值语句时表达式，
如此一来自增自减运算符就尤为另类。

副作用在某些情况下是我们需要的，
但在其他情况下成了难以避免的负面影响，
尤其在函数式编程中。
自增自减运算符的设计大大违背了函数式编程的不变性原则。
这给调试和debug带来了困难。

当然在纯函数式编程语言中当然不含有自增自减运算符，
一些混合范式（偏向函数式）的语言如 Scala 也不存在自增自减运算符。

## 新的工具

传统语言很依赖指针和自增运算符完成迭代等任务。
新式语言都采用了迭代式循环和范围等工具， 而非传统for循环，
即便 Go 也是如此。
Rust 更是直接删去了传统for循环。
各类传统语言也纷纷加入了迭代器， 范围等工具， 例如 C++。

举几个例子如下：

Java

``` Java
int[] arr = { 1, 2, 3, 4, 5 };

// old 
for (int i = 0; i < arr.length; i++) {
  System.out.println(arr[i];)
}

// new
for (int num : arr) {
  System.out.println(num);
}
```

JavaScript

``` JavaScript
const arr = [1, 2, 3, 4, 5]

// old
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i])
}

// new
for (const num of arr) {
  console.log(num)
}
```

Go

``` go
arr := [5]int{1, 2, 3, 4, 5}

// old
for i := 0; i < len(arr); i++ {
  fmt.Println(arr[i])
}

// new
for _, num:= range arr {
  fmt.Println(num)
}
```

如上文所示， 迭代器减少了代码量， 并使得代码更加清晰。

不仅如此， 迭代器减少了程序猿处理循环变量所需花费的精力，
并避免了错误修改循环变量所导致的bug。

请看如下 Python 代码：

``` python
for i in range(5):
  i -= 1
```

在这里修改变量 `i` 会导致bug吗？
并不会！

因为变量 `i` 并不参与循环逻辑， 只是每次从迭代器中取值，
对 `i` 的操作并不会影响到迭代器。
当然， 并不推荐写上述代码， 避免误会。

由于迭代器等新的工具替代了自增自减运算符的绝大部分使用环境，
并且更加简洁， 更加安全。
对于只存在迭代式循环的语言，
如 Python Rust等， 也就不会加入自增自减运算符了。

## 获取下标

在部分情况下， 循环中要用到数组下标，
此时， 自增运算符似乎更有优势。

然而， 各大语言早就考虑了这个问题。

例如python提供了enumerate函数，
该函数每次返回下标和可迭代对象：

``` python
lst = ['a', 'b', 'c', 'd', 'e']
for i, c in enumerate(lst):
    print(i, c)
```

Go也可以在迭代时获取下标：

``` go
lst = ['a', 'b', 'c', 'd', 'e']
for i, c in enumerate(lst):
    print(i, c)
```

在Swift中也一样：

``` swift
let arr: [String] = ["a", "b", "c", "d"]

for (i, c) in arr.enumerated() {
    print(i, c)
}
```

在Rust中：

``` rust
let arr = [1, 2, 3, 4, 5];
 
for (i, &num) in arr.iter().enumerate() {
    println!("arr[{}] = {}", i, num);
}
```

即使语言没有提供， 写一个类似函数并不是困难的。
如此， 自增自减运算符的使用场景就进一步减少了。

## 赋值语句的返回值

在 C/C++ 里赋值语句是有返回值的， C/C++ 程序猿喜欢写如下代码：

``` c
int a = 1, b = 2, c = 3;
a = (b += 3);
```

java 也可以这样写但 Java 程序猿似乎不喜欢这样写。

为什么赋值语句会有返回值？
这似乎是理所当然的事情， 看如下代码：

``` C
int a, b, c;
a = b = c = 5;
```

上述语句太过于自然， 过于符合直觉，
但这是因为赋值语句有返回值， 且赋值运算是右结合的，
这样才能实现连续赋值。

但是如今， 在许多现代语言里，
赋值语句不能作为表达式，
当然也就没有返回值。
不过， 这些语言中有些仍旧可以连续赋值，
这不是赋值语句返回值的结果，
纯粹是某种语法糖。

自增自减运算符作为赋值运算符的简化，
如果赋值运算符没有返回值，
自增自减运算符也不应该有返回值，
也就无法作为表达式使用了。
然而， 自增自减运算符主要用作表达式，
如此一来， 它的使用场景更加受限，
也没有加入的必要了。

## 运算符重载

对于内建运算符而言 `i++` 与 `i += 1` 同义，
`i--` 与 `i -= 1` 同义。

但引入运算符重载， 就有可能引入歧义。

第一种， 将自增自减视作赋值的语法糖。
当重载 `+=` 时， 默认重载 `++` ，
这对于一些类型会带来巨大的歧义，
例如python中字符串， `x = 'a'; x += 'b'` ，
此时 x 值为 'ab' ，
按照上述规则， `x++` 等价于 `x += 1`
x 的值就变成了 'ab1' ，
这是极其违反直觉的。

考虑一下在弱类型语言中这将产生什么样的灾难性后果，
JS现在即使没有运算符重载都能写出
`let a = []; a++`
然后a的值为0这种黑魔法代码了。
如果JS哪天加入了运算符重载，
然后有人闲着没事去重载了内置类型上的+=运算符，
那后果简直有点难以想象了。

第二种，将++视作与+=无关的操作符。
这样做不会产生上面描述中那样匪夷所思的问题，
但若选择这么做，当编程语言的使用者重载了+=运算符后，
可能会自然而然地认为++运算符也被重载了，这可能带来更多歧义。

事实上，这里提到的运算符重载带来的歧义已经在很多语言中发生了。
在同时支持自增自减运算符和操作符重载的语言中，
由于类似原因产生的BUG已经并不少见了。
一种解决方案是不允许重载++和--操作符，
只允许它们在整数类型上使用。
但既然这样了，为什么不考虑干脆去掉自增自减运算符呢？

## 总结

不得不说，Ken Thompson提出的 `++` 和 `--` 运算符产生的影响恐怕远远超出了本人的预料。
许多人对自增和自减运算符起源和应用场景的理解也仅仅是停留在想当然的层面，
诸如“提高运行效率”甚至“原子性操作”这样的误解也是满天飞。
同时，C语言初学者也常常被 `a = i++ + ++i + i++` 这种逆天未定义操作折腾到头疼欲裂。
这两个小小的运算符究既带来了方便也更多麻烦。

现如今越来越多的语言不加入自增自减运算符，
连 C++ 也推出各类工具减少对指针运算的依赖。
